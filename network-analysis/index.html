<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />

	<title>D2 network</title>
	<meta name="author" content="jargonautical" />
	<link rel="stylesheet" href="../css/drag-style.css" type="text/css"/>
	<link rel="stylesheet" href="../css/jarg.css" type="text/css"/>
	<link rel="shortcut icon" href="../assets/Jargonautical_web_icon.png"/>
	<div class='hero-image'></div>

	<script src="https://d3js.org/d3.v4.min.js"></script>
	<style>
	button {
	  position: relative;
	}

	.node {
		stroke: darkslategray;
		stroke-width: 2px;
	}
	.link {
		stroke: lightgray;
	}
	</style>
</head>

<body>
	<div style="text-align:center;">
		<button type="button" class="filter-btn" id="slice0" value="0">Slice 0</button>
		<button type="button" class="filter-btn" id="slice1" value="1">Slice 1</button>
		<button type="button" class="filter-btn" id="slice2" value="2">Slice 2</button>
		<button type="button" class="filter-btn" id="slice3" value="3">Slice 3</button>
		<button type="button" class="filter-btn" id="slice4" value="4">Slice 4</button>
		<button type="button" class="filter-btn" id="slice5" value="5">Slice 5</button>
		<button type="button" class="filter-btn" id="slice6" value="6">Slice 6</button>
		<button type="button" class="filter-btn" id="all" value="7">All</button>
		<svg width="960" height="500"></svg>
	</div>
</body>

<script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
<script>

//	data stores
var graph, store;

//	svg selection and sizing
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height"),
    radius = 10;

svg.append("rect")
.attr("width", "100%")
.attr("height", "100%")
.attr("fill", "white");

//	d3 color scales
var color = d3.scaleOrdinal(d3.schemeCategory10);
const scale = d3.scaleOrdinal()
				.domain([1,2])
				.range(["lightseagreen", "coral", "pink", "paleturquoise"]);

var link = svg.append("g").selectAll(".link"),
	node = svg.append("g").selectAll(".node");

//	force simulation initialization
var simulation = d3.forceSimulation()
	.force("link", d3.forceLink()
		.id(function(d) { return d.id; }))
	.force("charge", d3.forceManyBody(1)
		.strength(function(d) { return -100;}))
	.force("center", d3.forceCenter(width / 2, height / 2))
  .force("collision", d3.forceCollide(40));


//	filtered types
typeFilterList = [];

//	filter button event handlers
$(".filter-btn").on("click", function() {
	var id = $(this).attr("value");
	console.log('id chosen is ', id);
	typeFilterList.pop();
	typeFilterList.push(id);
	console.log('filtered list is ', typeFilterList);
	filter();
	update();
});

//	data read and store
d3.json("clandata2.json", function(err, g) {
	if (err) throw err;

	graph = g;
	store = $.extend(true, {}, g);

	update();
});

//	general update pattern for updating the graph
function update() {
	//	UPDATE
	node = node.data(graph.nodes, function(d) { return d.id;});
	//	EXIT
	node.exit().remove();
	//	ENTER
	var newNode = node.enter().append("circle")
		.attr("class", "node")
		.attr("r", function(d) { return d.role * 10; })
		.attr("fill", function(d) { return scale(d.group); })
		.call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended)
        )

    newNode.append("title")
      .text(function(d) { return "group: " + d.group + "\n" + "id: " + d.id; });
	//	ENTER + UPDATE

	  newNode.append("text")
			.text(function(d) {
				return d.code;
			})
			.style('fill', '#fff')
			.style('font-size', '14px')
			.style('font-family', 'sans-serif')
			.attr('x', -5)
			.attr('y', 5);
	node = node.merge(newNode);

	//	UPDATE
	link = link.data(graph.links1, function(d) { return d.id;});
	//	EXIT
	link.exit().remove();
	//	ENTER
	newLink = link.enter().append("line")
		.attr("class", "link")
		.attr("stroke", "lightgray")
		.attr("stroke-opacity", 0.6)
		.attr("stroke-width", d => d.weight);

	newLink.append("title")
      .text(function(d) { return "source: " + d.source + "\n" + "target: " + d.target; });
	//	ENTER + UPDATE
	link = link.merge(newLink);

	//	update simulation nodes, links, and alpha
	simulation
		.nodes(graph.nodes)
		.on("tick", ticked);

  	simulation.force("link")
  		.links(graph.links1);

  	simulation.alpha(1).alphaTarget(0).restart();
}

//	drag event handlers
function dragstarted(d) {
	if (!d3.event.active) simulation.alphaTarget(0.3).restart();
	d.fx = d.x;
	d.fy = d.y;
}

function dragged(d) {
	d.fx = d3.event.x;
	d.fy = d3.event.y;
}

function dragended(d) {
	if (!d3.event.active) simulation.alphaTarget(0);
	d.fx = null;
	d.fy = null;
}

//	tick event handler with bounded box
function ticked() {
	node
		.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
		.attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });

	link
		.attr("x1", function(d) { return d.source.x; })
		.attr("y1", function(d) { return d.source.y; })
		.attr("x2", function(d) { return d.target.x; })
		.attr("y2", function(d) { return d.target.y; });
}

//	filter function
function filter() {
	//clean up
	while (graph.links1.length) {
    graph.links1.pop();
	}
	//add and remove links from data
	// version that selects only selected timeframe
	store.links1.forEach(function(l) { // for each link
		//console.log('typeFilterList: ', typeFilterList[0], 'timeframe: ', l.timeframe, 'same? ', (typeFilterList[0]===l.timeframe));
		if (parseInt(typeFilterList[0]) !== 7 && typeFilterList[0] === l.timeframe ) {
				graph.links1.push($.extend(false, {}, l)); // extend the array with item l at position 1
			} else if (parseInt(typeFilterList[0]) === 7) {
				graph.links1.push($.extend(false, {}, l));
			}
	}
);
	console.log('filtered: ', graph);
}

</script>
</html>
